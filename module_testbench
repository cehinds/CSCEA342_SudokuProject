module testbench();

    // 1. Signals matching the DUT interface
    logic clk, reset;
    
    // Inputs to DUT
    logic [3:0] cmd_number;
    logic       cmd_up, 
                cmd_down, 
                cmd_left, 
                cmd_right, 
                cmd_enter;
    logic       cmd_valid;

    // Outputs from DUT
    logic [3:0] current_x, 
                current_y, 
                current_val;
    logic       game_won, game_lost;

    // 2. Instantiate the Device Under Test (DUT)
    sudoku_engine dut(
        .clk(clk),
        .reset(reset),
        .cmd_number(cmd_number),
        .cmd_up(cmd_up),
        .cmd_down(cmd_down),
        .cmd_left(cmd_left),
        .cmd_right(cmd_right),
        .cmd_enter(cmd_enter),
        .cmd_valid(cmd_valid),
        .current_x(current_x),
        .current_y(current_y),
        .current_val(current_val),
        .game_won(game_won),
        .game_lost(game_lost)
    );

    // 3. Testbench Memory (to hold the file data)
    logic [3:0] loaded_grid [0:80];
    logic [3:0] loaded_sol  [0:80];

    // Read the files once at the very start
    initial begin
        $readmemh("puzzle_1_init.hex", loaded_grid);
        $readmemh("puzzle_1_sol.hex", loaded_sol);
    end

    // 4. Clock Generation
    always begin
        clk = 1; #5; clk = 0; #5;
    end

    // --------------------------------------------------------
    // 5. TESTBENCH STATE MACHINE
    // --------------------------------------------------------

    // Define States for our Test Sequence
    typedef enum logic [4:0] {
        S_RESET,            // Apply Reset
        S_LOAD_PUZZLE,      // Copy file to DUT (replaces loop)
        
        // Test Vector 1: Movement
        S_MOVE_RIGHT_1,
        S_MOVE_RIGHT_2,
        S_MOVE_DOWN,
        S_CHECK_MOVE,       // Check if X=2, Y=1

        // Test Vector 2: Data Entry
        S_ENTRY_INPUT,      // Enter number '7'
        S_CHECK_ENTRY,      // Check if memory updated

        // Test Vector 3: Win Condition
        S_CHEAT_FILL,       // Fill grid with solution (replaces loop)
        S_SUBMIT,           // Press Enter
        S_CHECK_WIN,        // Verify Win signal

        S_DONE              // Stop simulation
    } state_t;

    state_t state;
    
    // Counter to replace 'for' loops
    integer counter; 
    
    // Calculate Row/Col based on counter (Counter goes 0-80)
    // 0-8 is Row 0, 9-17 is Row 1, etc.
    logic [3:0] r, c;
    assign r = counter / 9;
    assign c = counter % 9;

    // Sequential Logic (State Transitions & Outputs)
    always_ff @(posedge clk) begin
        
        // Default: Pulse signals should be 0 unless asserted in a state
        cmd_up    <= 0;
        cmd_down  <= 0;
        cmd_left  <= 0;
        cmd_right <= 0;
        cmd_enter <= 0;
        cmd_valid <= 0;
        cmd_number <= 0;

        // Reset Logic
        if (state == S_RESET && counter < 5) begin
             reset <= 1;
             counter <= counter + 1;
        end else if (state == S_RESET) begin
             reset <= 0;
             state <= S_LOAD_PUZZLE;
             counter <= 0; // Reset counter for next state
        end

        // State Machine
        case (state)
            
            // Initial Start
            S_RESET: begin
                // Handled in if-statement above
            end

            // ----------------------------------------------------
            // LOAD STATE: Iterates 0 to 80 (Replaces For-Loop)
            // ----------------------------------------------------
            S_LOAD_PUZZLE: begin
                // Copy data from local array to DUT
                dut.grid[c][r] <= loaded_grid[counter];
                dut.solution[c][r] <= loaded_sol[counter];
                
                // Handle Fixed Mask
                if (loaded_grid[counter] != 0)
                    dut.fixed_mask[c][r] <= 1;
                else
                    dut.fixed_mask[c][r] <= 0;

                // Counter Logic
                if (counter == 80) begin
                    state <= S_MOVE_RIGHT_1; // Move to next test
                    counter <= 0;
                    $display("Puzzle Loaded into DUT.");
                end else begin
                    counter <= counter + 1;
                end
            end

            // ----------------------------------------------------
            // TEST VECTOR 1: MOVEMENT
            // ----------------------------------------------------
            S_MOVE_RIGHT_1: begin
                cmd_right <= 1;
                cmd_valid <= 1;
                state <= S_MOVE_RIGHT_2;
            end

            S_MOVE_RIGHT_2: begin
                cmd_right <= 1;
                cmd_valid <= 1;
                state <= S_MOVE_DOWN;
            end

            S_MOVE_DOWN: begin
                cmd_down <= 1;
                cmd_valid <= 1;
                state <= S_CHECK_MOVE;
            end

            S_CHECK_MOVE: begin
                // Check if we are at X=2, Y=1
                if (current_x == 2 && current_y == 1)
                    $display("Test 1 (Movement): PASSED");
                else
                    $display("Test 1 (Movement): FAILED. Got X=%d, Y=%d", current_x, current_y);
                
                state <= S_ENTRY_INPUT;
            end

            // ----------------------------------------------------
            // TEST VECTOR 2: ENTRY
            // ----------------------------------------------------
            S_ENTRY_INPUT: begin
                // We are at (2,1). Let's enter the number 7.
                cmd_number <= 7;
                cmd_valid <= 1;
                state <= S_CHECK_ENTRY;
            end

            S_CHECK_ENTRY: begin
                // Check internal memory
                if (dut.grid[2][1] == 7)
                    $display("Test 2 (Entry): PASSED");
                else
                    $display("Test 2 (Entry): FAILED. Grid Value=%d", dut.grid[2][1]);

                state <= S_CHEAT_FILL;
                counter <= 0; // Reset counter for next loop
            end

            // ----------------------------------------------------
            // TEST VECTOR 3: WIN CONDITION
            // ----------------------------------------------------
            S_CHEAT_FILL: begin
                // Overwrite Grid with Solution (Replaces For-Loop)
                dut.grid[c][r] <= dut.solution[c][r];

                if (counter == 80) begin
                    state <= S_SUBMIT;
                    counter <= 0;
                    $display("Grid completely filled with solution.");
                end else begin
                    counter <= counter + 1;
                end
            end

            S_SUBMIT: begin
                cmd_enter <= 1;
                cmd_valid <= 1;
                state <= S_CHECK_WIN;
            end

            S_CHECK_WIN: begin
                if (game_won == 1) 
                    $display("Test 3 (Win Logic): PASSED");
                else 
                    $display("Test 3 (Win Logic): FAILED");
                
                state <= S_DONE;
            end

            S_DONE: begin
                $display("All Tests Completed.");
                $stop; // End Simulation
            end

        endcase
    end

    // Initialize State on Start
    initial begin
        state = S_RESET;
        counter = 0;
    end

endmodule
